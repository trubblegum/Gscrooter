Gscrooter is a super awesome platformer engine for LÖVE (a SCREWformer?), inpired by Gewter (a demo of Gspot, see below), but rebuilt from the ground up.

Kill the stuff! Count the hoppers! Protect your tree! Survive! Make your own levels! And more!

ToDo :
- scrolling backdrops
- fill out sounds
- add inventory
- your idea here

Editing :
map/mapname/map.lvl defines a map, which links to levels
map/mapname/map.png defines a background image for the map
Levels in /map can be loaded directly
If portal.level (as mapdir/level) then load map else return to menu

object defs will be loaded from (in this order) :
- classesdefault.lua - automatically at startup
- path specified in classes:load(path) - if forced
- map/mapname/<objectname>.lua - if map loaded and no defs.lua found
- map/mapname/defs.lua - if map loaded
- map/<objectname>.lua - if no map and no defs.lua
- map/defs.lua - if no map loaded

Note that all object class defs in a file are cached, and an object with an orphan def will not be loaded again if a matching def exists in cache. Use precedence to determine which def will load if multiple defs exist for the same class.

The first line in a .lvl is the floor, which defines the level's bounds (entity level objects wrap to level bounds)

Objects are divided into object and effect level tables. Generally, collisions are only checked against the object table
The default collision behaviour object.collide(this, condition) returns the first object found by iterating over world.objects using the following filters :
- obj ~= this
- function c(obj) derived from the condition supplied by optional second arg to collide (string lua assertion, such as "obj.type == 'platform'" or obj == player)
- - obj is the current object in an iteration over world.objects
- inherited intersect(this, obj) which should be a collision check function.
- - object.intersect(this, obj) is a basic bounding-box collision check.
- - effect.intersect(this, obj) is a bounding-box collision check which accounts for this.scale
Note that a reference to the player is always kept in global player.

Object defs in level1.lvl are minimal, but you can customize any object by adding attributes and functions to the prototype, and even override individual objects' update(this, dt) and draw(this) functions. It is generally wise to call a lower order's update and draw at the end of an override function.
Note that only object level objects are placed in a level file. Effects are generated on the fly and added using world:addeffect(classes.<objectname>(proto))
Object instances can also be created at runtime using world:addobject(classes.<objectname>(proto))

Some included example objects :
in classesdefault.lua :
- platform {p = {x, y, w}}
- scenery {p = {x, y}, bg = 'treetop1.png'} -- behaves like a platform, but renders bg behind, centered and aligned to bottom
- healtree {p = {x, y}, healing  = (HPS)} -- it has an AOE heal effect

in map/Gplace/defs.lua :
- hopper {{p = {x, y}, hp, damage = (DPS)} -- you know what this does
- hopperspawn {} -- just because this is how I did it, doesn't mean you have to
- bommer {}
- bommerspawn {}
- buzzer {}
- buzzerspawn {}
- slither {}
- slitherspawn {}

Includes an implementation of HUMP camera and vector from https://github.com/vrld/hump
Includes a modified implementation of Tserial from https://love2d.org/wiki/TLTools
Includes an implementation of Gspot from https://github.com/trubblegum/Gspot